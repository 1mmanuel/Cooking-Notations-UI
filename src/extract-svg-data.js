const fs = require("fs");
const path = require("path");
const xml2js = require("xml2js");

// --- Configuration ---
// Adjust this path if your SVG folder is located elsewhere relative to the project root
// Assuming the script is run from the project root directory
const svgFolderPath = path.join(__dirname, "SVG");
// Define the output file path (within the src directory)
const outputFilePath = path.join(__dirname, "iconPdfData.js");
// --- End Configuration ---

const parser = new xml2js.Parser({ explicitArray: false }); // explicitArray: false simplifies object access

// Helper function to recursively find all paths within SVG elements (like <g>)
function findPathsRecursive(element) {
  let paths = [];
  if (!element || typeof element !== "object") {
    return paths;
  }

  // Check if the current element itself is a path
  if (element.path) {
    const pathElements = Array.isArray(element.path)
      ? element.path
      : [element.path];
    pathElements.forEach((p) => {
      if (p && p.$ && p.$.d) {
        paths.push({
          d: p.$.d,
          fill: p.$.fill, // Include fill if present
          stroke: p.$.stroke, // Include stroke if present
          // Add other attributes like strokeWidth if needed: strokeWidth: p.$['stroke-width']
        });
      }
    });
  }

  // Recursively check children (common elements like <g>)
  for (const key in element) {
    if (key !== "$" && key !== "_" && typeof element[key] === "object") {
      const childElements = Array.isArray(element[key])
        ? element[key]
        : [element[key]];
      childElements.forEach((child) => {
        paths = paths.concat(findPathsRecursive(child));
      });
    }
  }

  // Special check for top-level path elements if the root <svg> tag itself contains paths directly
  if (element.$ && element.$.d && !paths.some((p) => p.d === element.$.d)) {
    paths.push({
      d: element.$.d,
      fill: element.$.fill,
      stroke: element.$.stroke,
    });
  }

  return paths;
}

async function extractSvgData() {
  const allIconData = {};
  console.log(`Reading SVG files from: ${svgFolderPath}\n`);

  try {
    const files = fs.readdirSync(svgFolderPath);
    const svgFiles = files.filter(
      (file) => path.extname(file).toLowerCase() === ".svg"
    );

    if (svgFiles.length === 0) {
      console.log("No SVG files found in the specified directory.");
      return;
    }

    for (const file of svgFiles) {
      const filePath = path.join(svgFolderPath, file);
      // Use filename without extension as ID, convert to camelCase maybe?
      // Or keep as is if your action IDs match the filenames directly.
      const iconId = path.basename(file, ".svg");

      try {
        const svgContent = fs.readFileSync(filePath, "utf-8");
        const parsedResult = await parser.parseStringPromise(svgContent);

        if (!parsedResult || !parsedResult.svg) {
          console.warn(`WARN: Could not parse SVG structure for ${file}`);
          continue;
        }

        const svgElement = parsedResult.svg;
        const viewBox = svgElement.$?.viewBox;

        if (!viewBox) {
          console.warn(`WARN: Missing viewBox attribute in ${file}`);
          // Consider adding a default or skipping if viewBox is essential
        }

        // Find all path elements recursively
        const paths = findPathsRecursive(svgElement);

        if (paths.length === 0) {
          console.warn(
            `WARN: No <path> elements with 'd' attribute found in ${file}`
          );
          // Consider skipping if paths are essential
        }

        // Clean up paths data (remove undefined fill/stroke)
        const cleanedPaths = paths.map((p) => ({
          d: p.d,
          ...(p.fill && { fill: p.fill }), // Only include fill if it exists
          ...(p.stroke && { stroke: p.stroke }), // Only include stroke if it exists
        }));

        allIconData[iconId] = {
          viewBox: viewBox || "0 0 24 24", // Provide a default viewBox if missing
          paths: cleanedPaths,
        };
        console.log(` -> Extracted data for: ${file}`);
      } catch (parseError) {
        console.error(
          `ERROR: Failed to read or parse ${file}:`,
          parseError.message
        );
      }
    } // End of for loop

    // --- Generate JavaScript file content ---
    // Add a comment indicating it's auto-generated
    const jsFileContent = `// This file is auto-generated by extract-svg-data.js
// Do not edit manually!

export default ${JSON.stringify(allIconData, null, 2)};
`; // Use JSON.stringify for easy object literal creation, then wrap in export default

    // --- Write the content to the output file ---
    try {
      fs.writeFileSync(outputFilePath, jsFileContent, "utf-8");
      console.log(
        `\n--- SVG Data successfully written to: ${outputFilePath} ---`
      );
    } catch (writeError) {
      console.error(
        `\nERROR: Failed to write SVG data to ${outputFilePath}:`,
        writeError.message
      );
    }
  } catch (dirError) {
    console.error(
      `ERROR: Could not read directory ${svgFolderPath}:`,
      dirError.message
    );
    console.error(
      "Please ensure the 'svgFolderPath' variable in the script is correct and the script is run from the project root."
    );
  }
}

extractSvgData();
